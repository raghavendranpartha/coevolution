{
    "contents" : "require(stringr)\ncorrelateERCGeneListTrees=function(treesObj, genelist, cutoff=NULL, transform=\"sqrt\", weighted=T, weights = NULL, useSpecies=NULL,  min.sp=10, scale=T,  doOnly=NULL, maxT=NULL, scaleForPproj=F, mean.trim=0.05){\n     \n     #      totalpairs <- choose(treesObj$numTrees,2)\n     #      treesObj = dtreall\n     #      genelist <- testset\n     #      cutoff<-NULL\n     #      transform=\"sqrt\"\n     #      weighted=T\n     #      weights = NULL\n     #      useSpecies=NULL\n     #      min.sp=5\n     #      scale=T\n     #      doOnly=NULL\n     #      maxT=NULL\n     #      scaleForPproj=F\n     #      mean.trim=0.05\n     \n     totalpairs <- choose(length(genelist),2)\n     \n     if(is.null(cutoff)){\n          cutoff=quantile(treesObj$paths, 0.05, na.rm=T)\n          message(paste(\"cutoff is set to\", cutoff))\n     }\n     if (weighted){\n          if(is.null(weights)){\n               message(\"Weights can not be NULL if weighted = T; computing weights\")\n               weights=computeWeightsAllVar(treesObj$paths, transform=transform, plot=T)\n          }\n          residfunc=fastLmResidMatWeighted\n     }else{\n          residfunc=fastLmResidMat\n     }\n     \n     if (is.null(useSpecies)){\n          useSpecies=treesObj$masterTree$tip.label\n          #mappedEdges=trees$mappedEdges\n     }\n     if(is.null(maxT)){\n          maxT=treesObj$numTrees\n     }\n     if(transform!=\"none\"){\n          transform=match.arg(transform,c(\"sqrt\", \"log\"))\n          transform=get(transform)\n     }else{\n          transform=NULL\n     }\n     #cm is the names of species that are included in useSpecies and the master tree\n     cm=intersect(treesObj$masterTree$tip.label, useSpecies)\n     sp.miss = setdiff(treesObj$masterTree$tip.label, useSpecies)\n     if (length(sp.miss) > 0) {\n          message(paste0(\"Species from master tree not present in useSpecies: \", paste(sp.miss,\n                                                                                       collapse = \",\")))\n          \n     }\n     \n     corout=matrix(NA,treesObj$numTrees,treesObj$numTrees)\n     diag(corout) = 1\n     \n     geneis <- sort(match(genelist, names(treesObj$trees)))\n     #genejs <- match(genelist, names(treesObj$trees))\n     \n     maxn2=treesObj$report%*%t(treesObj$report)\n     maxn2[upper.tri(maxn2, diag = T)] = NA\n     corout[which(maxn2 == 0)] <- Inf\n     \n     \n     #      if(is.null(doOnly)){\n     #           doOnly=1\n     #      }else{\n     #           maxT=1\n     #      }\n     pairsdone <- 0\n     print(maxT)\n     for (i in geneis){\n          for(j in geneis){\n               if(i < j){\n                    next\n               }\n               print(paste0(i,'',j))\n               #print(j)\n               #i <- 480\n               #j <- 2\n               #i <- 160\n               #j <- 67\n               if(is.na(corout[i,j])){\n                    #tree1=treesObj$trees[[i]]\n                    #get the common species, prune and unroot\n                    both=intersect(intersect(treesObj$trees[[i]]$tip, treesObj$trees[[j]]$tip), cm)\n                    nb=length(both)\n                    if(nb>2){\n                         tree1=unroot(pruneTree(treesObj$master,both))\n                    }\n                    #find all the genes that contain all of the species in tree1\n                    allreport=treesObj$report[,both]\n                    if(nb>1){\n                         ss=rowSums(allreport)\n                    }else{\n                         ss=allreport\n                    }\n                    iiboth=which(ss==length(both))\n                    ai2=which(maxn2[iiboth, iiboth]==nb, arr.ind = T)\n                    \n                    if(length(both)<min.sp){\n                         corout[matrix(iiboth[ai2],nrow=nrow(ai2))]=Inf\n                         ai2rev <- ai2\n                         ai2rev[,1] <- ai2[,2]\n                         ai2rev[,2] <- ai2[,1]\n                         corout[matrix(iiboth[ai2rev],nrow=nrow(ai2rev))]=1\n                         pairsdone <- pairsdone+nrow(ai2)\n                         #message(paste0(pairsdone,\" done out of \",totalpairs))\n                         next\n                    }    \n                    \n                    \n                    if(T){\n                         \n                         \n                         ee=edgeIndexRelativeMaster(tree1, treesObj$masterTree)\n                         \n                         ii= treesObj$matIndex[ee[, c(2,1)]]\n                         \n                         allbranch=treesObj$paths[iiboth,ii]\n                         if(weighted){\n                              allbranchw=weights[iiboth,ii]\n                         }\n                         if(scaleForPproj){\n                              nv=apply(scaleMatMean(allbranch), 2, mean, na.rm=T, trim=mean.trim)\n                         }else{\n                              nv=apply(allbranch, 2, mean, na.rm=T, trim=mean.trim)\n                         }\n                         \n                         iibad=which(allbranch<cutoff)\n                         #don't scale\n                         #allbranch=scaleMat(allbranch)\n                         if(!is.null(transform)){\n                              nv=transform(nv)\n                              allbranch=transform(allbranch)\n                         }\n                         allbranch[iibad]=NA\n                         \n                         if(!scale){\n                              if(!weighted){\n                                   proj=residfunc(allbranch, model.matrix(~1+nv))\n                                   \n                              }else{\n                                   \n                                   proj=residfunc(allbranch, model.matrix(~1+nv), allbranchw)\n                                   \n                              }\n                         }else{\n                              \n                              if(!weighted){\n                                   proj=residfunc(allbranch, model.matrix(~1+nv))\n                              }else{\n                                   \n                                   proj=residfunc(allbranch, model.matrix(~1+nv),allbranchw)\n                              }\n                              \n                              proj=scale(proj, center = F)\n                              \n                         }\n                         \n                         \n                         #we have the projection\n                         \n                         for(m in 1:nrow(ai2)){\n                              #m = 1\n                              #print(m)\n                              k=sort(ai2[m,])[1]\n                              l=sort(ai2[m,])[2]\n                              #tmpcor=cor(proj[k,], proj[l,], method = 'p', use = 'pair')\n                              if(sum(!is.na(proj[k,])&!is.na(proj[l,])) > 4){\n                                   cres=cor.test(win(proj[k,],3), win(proj[l,],3), method='pearson', exact=F)\n                                   corout[iiboth[l], iiboth[k]]=cres$est\n                              }else{\n                                   corout[iiboth[l], iiboth[k]]=Inf\n                              }\n                              corout[iiboth[k], iiboth[l]]=1\n                         }\n                         pairsdone <- pairsdone+nrow(ai2)\n                         #message(paste0(pairsdone,\" done out of \",totalpairs))\n                    }\n                    \n               }\n               \n          }\n     }\n     rownames(corout) <- names(treesObj$trees)\n     colnames(corout) <- names(treesObj$trees)\n     corout[geneis,geneis]\n}\ncorrelateERCTreesinProjection <- function(treesObj, dfprojns = NULL, cutoff=NULL, transform=\"sqrt\", weighted=T, weights = NULL, useSpecies=NULL,  min.sp=10, scale=T,  doOnly=NULL, maxT=NULL, scaleForPproj=F, mean.trim=0.05){\n     \n#      treesObj = dtre\n#      cutoff=NULL\n#      transform=\"sqrt\"\n#      weighted=T\n#      weights = weights.sqrt\n#      useSpecies=NULL\n#      min.sp=3\n#      scale=T\n#      doOnly=NULL\n#      maxT=NULL\n#      scaleForPproj=F\n#      mean.trim=0.05\n#      dfprojns = readRDS('../data/saves/onekdroso20.tre.projns.rds')\n#      genepairsprojn = readRDS('../data/saves/onekdroso20.tre.projnGenepair.rds')\n     \n     if(is.null(dfprojns)){\n          stop('Projection objects not supplied')\n     }\n     if(is.null(cutoff)){\n          cutoff=quantile(treesObj$paths, 0.05, na.rm=T)\n          message(paste(\"cutoff is set to\", cutoff))\n     }\n     #cutoff = 0\n     if (weighted){\n          #weights=computeWeightsAllVar(treesObj$paths, transform=transform, plot=T)\n          if(is.null(weights)){\n               message(\"Weights can not be NULL if weighted = T; computing weights\")\n               weights=computeWeightsAllVar(treesObj$paths, transform=transform, plot=T)\n          }\n          residfunc=fastLmResidMatWeighted\n     }else{\n          residfunc=fastLmResidMat\n     }\n     # residfunc=naresid\n     \n     if (is.null(useSpecies)){\n          useSpecies=treesObj$masterTree$tip.label\n          #mappedEdges=trees$mappedEdges\n     }\n     if(is.null(maxT)){\n          maxT=treesObj$numTrees\n     }\n     if(transform!=\"none\"){\n          transform=match.arg(transform,c(\"sqrt\", \"log\"))\n          transform=get(transform)\n     }else{\n          transform=NULL\n     }\n     \n     \n     \n     #cm is the names of species that are included in useSpecies and the master tree\n     cm=intersect(treesObj$masterTree$tip.label, useSpecies)\n     sp.miss = setdiff(treesObj$masterTree$tip.label, useSpecies)\n     if (length(sp.miss) > 0) {\n          message(paste0(\"Species from master tree not present in useSpecies: \", paste(sp.miss,\n                                                                                       collapse = \",\")))\n          \n     }\n     \n     corout=matrix(0,nrow(treesObj$paths),nrow(treesObj$paths))\n     diag(corout)=1\n     #corout[lower.tri(corout, diag = F)] <- 0\n     pairsdone <- 0\n     totalpairs <- 'N/A'\n     \n     #maxn=rowSums(treesObj$report[,cm])\n     \n     maxn2=treesObj$report%*%t(treesObj$report)\n     maxn2[upper.tri(maxn2, diag = T)] = NA\n     \n     for (projnum in 1:nrow(dfprojns)){\n          #projnum = 174\n          print(projnum)\n          #genepairs <- which(genepairsprojn==projnum, arr.ind = T)\n          both = intersect(colnames(treesObj$report)[as.logical(as.numeric(strsplit(dfprojns$projout[projnum],'')[[1]]))],\n                           cm)\n          nb=length(both)\n          #tree1 <- treesObj$trees[[genepairs[1,1]]]\n          if(nb>2){\n               tree1=unroot(pruneTree(treesObj$master,both))\n          }\n          #find all the genes that contain all of the species in tree1\n          allreport=treesObj$report[,both]\n          if(nb>1){\n               ss=rowSums(allreport)\n          }else{\n               ss=allreport\n          }\n          iiboth=which(ss==length(both))\n          ai2=which(maxn2[iiboth, iiboth]==nb, arr.ind = T)\n          \n          if(length(both)<min.sp){\n               #donei[iiboth[ai]]=1\n               corout[matrix(iiboth[ai2],nrow=nrow(ai2))]=Inf\n               ai2rev <- ai2\n               ai2rev[,1] <- ai2[,2]\n               ai2rev[,2] <- ai2[,1]\n               corout[matrix(iiboth[ai2rev],nrow=nrow(ai2rev))]=1\n               pairsdone <- pairsdone+nrow(ai2)\n               message(paste0(pairsdone,\" done out of \",totalpairs))\n               next\n          }    \n          \n          if(T){\n               \n               ee=edgeIndexRelativeMaster(tree1, treesObj$masterTree)\n               \n               ii= treesObj$matIndex[ee[, c(2,1)]]\n               \n               allbranch=treesObj$paths[iiboth,ii]\n               if(weighted){\n                    allbranchw=weights[iiboth,ii]\n               }\n               if(scaleForPproj){\n                    nv=apply(scaleMatMean(allbranch), 2, mean, na.rm=T, trim=mean.trim)\n               }else{\n                    nv=apply(allbranch, 2, mean, na.rm=T, trim=mean.trim)\n               }\n               \n               iibad=which(allbranch<cutoff)\n               #don't scale\n               #allbranch=scaleMat(allbranch)\n               if(!is.null(transform)){\n                    nv=transform(nv)\n                    allbranch=transform(allbranch)\n               }\n               allbranch[iibad]=NA\n               \n               if(!scale){\n                    if(!weighted){\n                         proj=residfunc(allbranch, model.matrix(~1+nv))\n                         \n                    }else{\n                         \n                         proj=residfunc(allbranch, model.matrix(~1+nv), allbranchw)\n                         \n                    }\n               }else{\n                    \n                    if(!weighted){\n                         proj=residfunc(allbranch, model.matrix(~1+nv))\n                    }else{\n                         \n                         proj=residfunc(allbranch, model.matrix(~1+nv),allbranchw)\n                    }\n                    \n                    proj=scale(proj, center = F)                    \n               }\n          }\n               \n          for(m in 1:nrow(ai2)){\n               #m = 1\n               #print(m)\n               k=sort(ai2[m,])[1]\n               l=sort(ai2[m,])[2]\n               #tmpcor=cor(proj[k,], proj[l,], method = 'p', use = 'pair')\n               if(sum(!is.na(proj[k,])&!is.na(proj[l,])) > 4){\n                    cres=cor.test(win(proj[k,],3), win(proj[l,],3), method='pearson', exact=F)\n                    corout[iiboth[l], iiboth[k]]=cres$est\n               }else{\n                    corout[iiboth[l], iiboth[k]]=Inf\n               }\n\t       corout[iiboth[k],iiboth[l]] <- 1\n               #print(m)\n          }\n          pairsdone <- pairsdone+nrow(ai2)\n          message(paste0(pairsdone,\" done out of \",totalpairs))\n     }\n     corout\n}\ngetAllProjections_single <- function(treesrdsfilepath){\n     trefile <- gsub('.rds','',tail(strsplit(treesrdsfilepath,'/')[[1]],n =1))\n     treeObj <- readRDS(treesrdsfilepath)\n     treesreport <- treeObj$report\n     rm('treeObj')\n     maxn=treesreport%*%t(treesreport)\n     ltmaxn <- which(lower.tri(maxn), arr.ind = T)\n     rm('maxn')\n     print(paste0(nrow(ltmaxn),' gene pairs'))\n     print(Sys.time())\n     res <- sapply(1:nrow(ltmaxn), function(x){\n          if(x %% 1000000 == 0){\n               print(x)\n               print(Sys.time())\n          }\n          paste(treesreport[ltmaxn[x,1],]*treesreport[ltmaxn[x,2],], collapse = '')\n     })\n     print(Sys.time())\n     resdf <- data.frame(projout = res, stringsAsFactors = F) \n     rm('res')\n     resdf %>% group_by(projout) %>% summarise(nPairs = length(projout)) %>%\n          arrange(projout) %>% \n          mutate(nSpecies = sapply(projout,function(y) str_count(y,'1'), USE.NAMES = F))\n}\nwin=function(x,w){\n     if(length(sum(!is.na(x))<4)){\n          return(x)\n     }\n     xs=sort(x[!is.na(x)], decreasing = T)\n     xmax=xs[w]\n     xmin=xs[length(xs)-w+1]\n     \n     x[x>xmax]=xmax\n     x[x<xmin]=xmin\n     x\n}\ncorrelateERCAllTrees=function(treesObj, cutoff=NULL, transform=\"sqrt\", weighted=T, weights = NULL, useSpecies=NULL,  min.sp=10, scale=T,  doOnly=NULL, maxT=NULL, scaleForPproj=F, mean.trim=0.05){\n     \n     totalpairs <- choose(treesObj$numTrees,2)\n     #      treesObj = dtre\n     #      cutoff<-NULL\n     #      transform=\"sqrt\"\n     #      weighted=T\n     #      weights = weights.sqrt\n     #      useSpecies=NULL\n     #      min.sp=5\n     #      scale=T\n     #      doOnly=NULL\n     #      maxT=NULL\n     #      scaleForPproj=F\n     #      mean.trim=0.05\n     \n     \n     if(is.null(cutoff)){\n          cutoff=quantile(treesObj$paths, 0.05, na.rm=T)\n          message(paste(\"cutoff is set to\", cutoff))\n     }\n     if (weighted){\n          if(is.null(weights)){\n               message(\"Weights can not be NULL if weighted = T; computing weights\")\n               weights=computeWeightsAllVar(treesObj$paths, transform=transform, plot=T)\n          }\n          residfunc=fastLmResidMatWeighted\n     }else{\n          residfunc=fastLmResidMat\n     }\n     \n     if (is.null(useSpecies)){\n          useSpecies=treesObj$masterTree$tip.label\n          #mappedEdges=trees$mappedEdges\n     }\n     if(is.null(maxT)){\n          maxT=treesObj$numTrees\n     }\n     if(transform!=\"none\"){\n          transform=match.arg(transform,c(\"sqrt\", \"log\"))\n          transform=get(transform)\n     }else{\n          transform=NULL\n     }\n     #cm is the names of species that are included in useSpecies and the master tree\n     cm=intersect(treesObj$masterTree$tip.label, useSpecies)\n     sp.miss = setdiff(treesObj$masterTree$tip.label, useSpecies)\n     if (length(sp.miss) > 0) {\n          message(paste0(\"Species from master tree not present in useSpecies: \", paste(sp.miss,\n                                                                                       collapse = \",\")))\n          \n     }\n     \n     corout=matrix(NA,treesObj$numTrees,treesObj$numTrees)\n     diag(corout) = 1\n     \n     maxn2=treesObj$report%*%t(treesObj$report)\n     maxn2[upper.tri(maxn2, diag = T)] = NA\n     \n     #      if(is.null(doOnly)){\n     #           doOnly=1\n     #      }else{\n     #           maxT=1\n     #      }\n     pairsdone <- 0\n     print(maxT)\n     for (i in 2:maxT){\n          for(j in 1:(i-1)){\n               #i <- 480\n               #j <- 2\n               #i <- 160\n               #j <- 67\n               if(is.na(corout[i,j])){\n                    #tree1=treesObj$trees[[i]]\n                    #get the common species, prune and unroot\n                    both=intersect(intersect(treesObj$trees[[i]]$tip, treesObj$trees[[j]]$tip), cm)\n                    nb=length(both)\n                    if(nb>2){\n                         tree1=unroot(pruneTree(treesObj$master,both))\n                    }\n                    #find all the genes that contain all of the species in tree1\n                    allreport=treesObj$report[,both]\n                    if(nb>1){\n                         ss=rowSums(allreport)\n                    }else{\n                         ss=allreport\n                    }\n                    iiboth=which(ss==length(both))\n                    ai2=which(maxn2[iiboth, iiboth]==nb, arr.ind = T)\n                    \n                    if(length(both)<min.sp){\n                         corout[matrix(iiboth[ai2],nrow=nrow(ai2))]=Inf\n                         ai2rev <- ai2\n                         ai2rev[,1] <- ai2[,2]\n                         ai2rev[,2] <- ai2[,1]\n                         corout[matrix(iiboth[ai2rev],nrow=nrow(ai2rev))]=1\n                         pairsdone <- pairsdone+nrow(ai2)\n                         message(paste0(pairsdone,\" done out of \",totalpairs))\n                         next\n                    }    \n                    \n                    \n                    if(T){\n                         \n                         \n                         ee=edgeIndexRelativeMaster(tree1, treesObj$masterTree)\n                         \n                         ii= treesObj$matIndex[ee[, c(2,1)]]\n                         \n                         allbranch=treesObj$paths[iiboth,ii]\n                         if(weighted){\n                              allbranchw=weights[iiboth,ii]\n                         }\n                         if(scaleForPproj){\n                              nv=apply(scaleMatMean(allbranch), 2, mean, na.rm=T, trim=mean.trim)\n                         }else{\n                              nv=apply(allbranch, 2, mean, na.rm=T, trim=mean.trim)\n                         }\n                         \n                         iibad=which(allbranch<cutoff)\n                         #don't scale\n                         #allbranch=scaleMat(allbranch)\n                         if(!is.null(transform)){\n                              nv=transform(nv)\n                              allbranch=transform(allbranch)\n                         }\n                         allbranch[iibad]=NA\n                         \n                         if(!scale){\n                              if(!weighted){\n                                   proj=residfunc(allbranch, model.matrix(~1+nv))\n                                   \n                              }else{\n                                   \n                                   proj=residfunc(allbranch, model.matrix(~1+nv), allbranchw)\n                                   \n                              }\n                         }else{\n                              \n                              if(!weighted){\n                                   proj=residfunc(allbranch, model.matrix(~1+nv))\n                              }else{\n                                   \n                                   proj=residfunc(allbranch, model.matrix(~1+nv),allbranchw)\n                              }\n                              \n                              proj=scale(proj, center = F)\n                              \n                         }\n                         \n                         \n                         #we have the projection\n                         \n                         for(m in 1:nrow(ai2)){\n                              #m = 1\n                              #print(m)\n                              k=sort(ai2[m,])[1]\n                              l=sort(ai2[m,])[2]\n                              #tmpcor=cor(proj[k,], proj[l,], method = 'p', use = 'pair')\n                              if(sum(!is.na(proj[k,])&!is.na(proj[l,])) > 4){\n                                   cres=cor.test(win(proj[k,],3), win(proj[l,],3), method='pearson', exact=F)\n                                   corout[iiboth[l], iiboth[k]]=cres$est\n                              }else{\n                                   corout[iiboth[l], iiboth[k]]=Inf\n                              }\n                              corout[iiboth[k], iiboth[l]]=1\n                         }\n                         pairsdone <- pairsdone+nrow(ai2)\n                         message(paste0(pairsdone,\" done out of \",totalpairs))\n                    }\n                    \n               }\n               \n          }\n     }\n     rownames(corout) <- names(treesObj$trees)\n     colnames(corout) <- names(treesObj$trees)\n     corout\n}\n\n",
    "created" : 1551467002213.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "502631919",
    "id" : "9434B2C5",
    "lastKnownWriteTime" : 1551300949,
    "path" : "~/Documents/erc/code/funcsERCfromProjections.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}